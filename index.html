<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The New Invisible College</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
  :root {
    --paper-bg: #faf8f2;
    --paper-border: #d4cfc3;
    --ink: #3a3a3a;
    --ink-soft: #615c54;
    --accent: #8c6b45; 
  }

  body {
    margin: 0; padding: 0;
    font-family: "Libre Baskerville", serif;
    background: var(--paper-bg); color: var(--ink);
    line-height: 1.6;
  }

  header {
    text-align: center; padding: 2rem 0;
    border-bottom: 1px solid var(--paper-border);
    margin-bottom: 1rem;
  }

  .container {
    width: 95%; max-width: 1400px;
    margin: auto; display: flex; gap: 1.5rem;
  }

  /* Sidebar styling */
  .sidebar {
    width: 320px; height: 650px;
    border: 1px solid var(--paper-border);
    background: #fdfbf6; padding: 1.5rem;
    border-radius: 8px; overflow-y: auto;
  }

  .sidebar h2 { font-size: 1.2rem; color: var(--accent); border-bottom: 1px solid #eee; }
  .relation-item { margin-bottom: 1rem; font-size: 0.9rem; border-left: 3px solid var(--accent); padding-left: 0.5rem; }

  /* Diagram area */
  .diagram-container {
    flex: 1; height: 650px;
    border: 1px solid var(--paper-border);
    background: #ffffff; border-radius: 8px;
    position: relative; overflow: hidden;
  }

  svg { width: 100%; height: 100%; cursor: grab; }
  .node circle { transition: r 0.3s, fill 0.3s; cursor: pointer; }
  .node:hover circle { r: 16; fill: #fff5e6; }
  .link { stroke: #d4cfc3; stroke-opacity: 0.4; transition: stroke 0.3s; }
  .link.highlight { stroke: var(--accent); stroke-opacity: 1; stroke-width: 2px; }
  .node-label { font-size: 12px; font-weight: bold; fill: var(--ink); pointer-events: none; }
  .group-label { font-size: 14px; font-style: italic; fill: var(--ink-soft); opacity: 0.5; }
</style>
</head>

<body>

<header>
  <div style="font-size: 2.2rem; font-weight: 600;">The New Invisible College</div>
  <div style="color: var(--ink-soft);">A Genealogy of Modern Physics</div>
</header>

<div class="container">
  <aside class="sidebar" id="sidebar">
    <div id="default-msg">
      <h2>Instructions</h2>
      <p>Click a scientist to explore their academic lineage and connections.</p>
    </div>
    <div id="content-area" style="display:none;">
      <h2 id="selected-name">Name</h2>
      <p id="selected-bio" style="font-style: italic; margin-bottom: 1.5rem;"></p>
      <div id="connections-list"></div>
    </div>
  </aside>

  <section class="diagram-container">
    <svg id="network"></svg>
  </section>
</div>

<script>
/* 1. DATASET: 你只需要维护这两个数组 */
const groups = {
  stat: { label: "Statistical Physics", x: 200, y: 150 },
  quantum: { label: "Quantum Mechanics", x: 500, y: 350 },
  nuclear: { label: "Nuclear Physics", x: 800, y: 150 }
};

const nodes = [
  { id: "boltzmann", label: "Boltzmann", group: "stat", bio: "奠基了统计力学，引入熵的统计定义 $S = k \\ln W$。" },
  { id: "planck", label: "Planck", group: "quantum", bio: "发现量子常数 $h$。" },
  { id: "bohr", label: "Bohr", group: "quantum", bio: "哥本哈根学派教父。" },
  { id: "heisenberg", label: "Heisenberg", group: "quantum", bio: "矩阵力学创立者。" },
  { id: "meitner", label: "Meitner", group: "nuclear", bio: "发现核裂变的关键证据。" }
];

const links = [
  { source: "boltzmann", target: "planck", note: "Planck borrowed Boltzmann's statistical methods to solve blackbody radiation." },
  { source: "planck", target: "bohr", note: "Bohr quantized electronic orbits using Planck's constant $h$." },
  { source: "bohr", target: "heisenberg", note: "Heisenberg was Bohr's most influential student in Copenhagen." }
];

/* 2. ENGINE: 自动渲染逻辑 */
const svg = document.getElementById("network");
const viewport = document.createElementNS("http://www.w3.org/2000/svg", "g");
svg.appendChild(viewport);

// 计算布局
nodes.forEach((node, i) => {
  const g = groups[node.group];
  node.x = g.x + (i % 3) * 80; 
  node.y = g.y + Math.floor(i / 3) * 80;
});

// 画线
links.forEach(link => {
  const s = nodes.find(n => n.id === link.source);
  const t = nodes.find(n => n.id === link.target);
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("class", `link link-from-${link.source} link-to-${link.target}`);
  line.setAttribute("x1", s.x); line.setAttribute("y1", s.y);
  line.setAttribute("x2", t.x); line.setAttribute("y2", t.y);
  viewport.appendChild(line);
});

// 画点
nodes.forEach(node => {
  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  g.setAttribute("class", "node");
  
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", node.x); circle.setAttribute("cy", node.y);
  circle.setAttribute("r", 12); circle.setAttribute("fill", "white");
  circle.setAttribute("stroke", "var(--accent)"); circle.setAttribute("stroke-width", "2");
  
  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("x", node.x); text.setAttribute("y", node.y + 25);
  text.setAttribute("text-anchor", "middle"); text.setAttribute("class", "node-label");
  text.textContent = node.label;

  g.appendChild(circle); g.appendChild(text);
  g.onclick = () => showDetails(node);
  viewport.appendChild(g);
});

// 交互逻辑
function showDetails(node) {
  // 高亮线
  document.querySelectorAll('.link').forEach(l => l.classList.remove('highlight'));
  document.querySelectorAll(`.link-from-${node.id}, .link-to-${node.id}`).forEach(l => l.classList.add('highlight'));

  // 填充侧边栏
  document.getElementById('default-msg').style.display = 'none';
  document.getElementById('content-area').style.display = 'block';
  document.getElementById('selected-name').textContent = node.label;
  document.getElementById('selected-bio').innerHTML = node.bio;

  const related = links.filter(l => l.source === node.id || l.target === node.id);
  const listHtml = related.map(l => {
    const otherId = l.source === node.id ? l.target : l.source;
    const otherNode = nodes.find(n => n.id === otherId);
    return `<div class="relation-item"><strong>With ${otherNode.label}:</strong><br>${l.note}</div>`;
  }).join('');
  
  document.getElementById('connections-list').innerHTML = listHtml;
  
  // 重新渲染侧边栏中的数学公式
  MathJax.typeset();
}
</script>
</body>
</html>
